import secrets
import socket
import time
import random
import hashlib
import json
import threading

from base64 import b64encode

from secretsharing import SecretSharer
from cryptography.hazmat.primitives.asymmetric import ec
from cryptography.hazmat.primitives import serialization

import helper
from bloom import *
from helper import *


# client
broadcast_ip = '255.255.255.255'
port = 12345
n = 5
k = 3  # received >= 3 shares of the same EphID
receive_time_out = 9  # This means that if the nodes have remained in contact for at least 9 seconds
drop_rate = 0.5  # If this number is less than 0.5, donâ€™t transmit that message
interval = 15  # seconds between new EphID generation
dbf_servant_cycle = 90  # A DBF will store all EncIDs representing encounters faced during a 90-second period
max_size = 6  # A node can only store maximum of 6 DBFs.

bloom_fiter_size = 10000
node_id = secrets.token_hex(1)  # Generate a unique UUID for this node

dbf_list = []
dbf = BloomFilter(bloom_fiter_size)

is_virus_infected = False

private_key = None

lock = threading.Lock()


def generate_key_pair():
    private_key = ec.generate_private_key(ec.SECP256R1())
    public_key = private_key.public_key()
    return private_key, public_key


def generate_ephid():
    """Generate a 32-byte ephemeral ID and its hash."""
    private_key, public_key = generate_key_pair()
    # get the x from public key it has 32bytes
    ephid = public_key.public_bytes(
        encoding=serialization.Encoding.X962,
        format=serialization.PublicFormat.CompressedPoint
    )[1:]

    ephid_hash = hashlib.sha256(ephid).hexdigest()
    return private_key, ephid, ephid_hash


def split_ephid(ephid):
    """Split the EphID into shares."""
    hex_ephid = ephid.hex()
    shares = SecretSharer.split_secret(hex_ephid, k, n)
    return shares


def send_bf(client, bf, keyword):
    """Sending bloom filters to server"""
    bf_str = b64encode(bf).decode()
    msg = keyword + bf_str  # Keyword = cbf or qbf
    client.send(msg.encode())


def broadcast_shares(shares, ephid_hash, node_id):
    """Broadcast each share over UDP with 3 seconds interval and incorporate drop mechanism."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)

    for share in shares:
        if random.random() > drop_rate:
            msg = {'share': share, 'ephid_hash': ephid_hash, 'node_id': node_id}
            msg_json = json.dumps(msg)
            sock.sendto(msg_json.encode(), (broadcast_ip, port))
            print_colored(f"3-A\n"
                          f"Share broadcasting: {share}"
                          , 'green')
        else:
            print_colored(f"3-A\n"
                          f"Share dropping: {share}"
                          , 'green', ["underline"])

        time.sleep(3)


def reconstruct_shares(received_shares, ephid_hash):
    """Reconstruct the EphID from received shares."""
    hex_ephid = SecretSharer.recover_secret(received_shares[:k])
    ephid = bytes.fromhex(hex_ephid.zfill(len(hex_ephid) + len(hex_ephid) % 2))

    reconstructed_ephid_hash = hashlib.sha256(ephid).hexdigest()
    if reconstructed_ephid_hash == ephid_hash:
        print_colored(f"4-B\n"
                      f"the received hash: {ephid_hash}\n"
                      f"the reconstructed_hash: {reconstructed_ephid_hash}"
                      , 'red')
        return ephid, reconstructed_ephid_hash
    else:
        print_colored(f"EphID hash does not match.\n"
                      f"ephid: {ephid.hex()}"
                      f"shares: {received_shares}"
                      , 'red')

        return None, None


def generate_encid(my_private_key, x_peer_public_key):
    y_parity_values = [0x02, 0x03]  # 0x02 for even y, 0x03 for odd y

    for y_parity in y_parity_values:
        try:
            compressed_pubkey = bytes([y_parity]) + x_peer_public_key
            peer_public_key = ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP256R1(), compressed_pubkey)
            # If we reach here, the public key was successfully created
            shared_secret = my_private_key.exchange(ec.ECDH(), peer_public_key)
            pem = private_key.private_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PrivateFormat.TraditionalOpenSSL,
                encryption_algorithm=serialization.NoEncryption()
            )
            encounter_id = shared_secret
            print_colored(f"5-A\n"
                          f"Shared_secret generated by\n"
                          f"peer's public key : {compressed_pubkey.hex()}\n"
                          f"with my private_key: {pem.hex()}"
                          , 'red')

            return encounter_id
        except ValueError as e:
            # Handle the case where the reconstruction fails
            # print(f"Failed to reconstruct public key with parity {hex(y_parity)}: {e}")
            continue
    print_colored("Failed to reconstruct public key with provided x-coordinate")


def create_bloom_filter():
    """create bloom filter using bloom referenced from online"""
    return BloomFilter(bloom_fiter_size)


def upload_bf_to_backend(qbf, bf_type='qbf'):
    """send the bloom filter to server using tcp socket"""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
        sock.connect((helper.BACKEND_SERVER_IP, helper.BACKEND_SERVER_PORT))
        send_bf(sock, qbf.bit_array, f"{bf_type}|")

        result = sock.recv(1024).decode()
        print_colored(f"10-B\n"
                      f"Received result from server: {result}", 'magenta', attrs=['underline'])
        return result


def create_new_dbf():
    """every cycle create a new dbf"""
    global dbf_list, dbf
    start_time = time.time()

    while True:
        with lock:
            if len(dbf_list) > max_size:
                print_colored(f"7-B\n"
                              f" the size of dbf_list is {len(dbf_list)} which exceed maximum size {max_size}", 'blue')
                dbf_list.pop(0)
        if time.time() - start_time >= dbf_servant_cycle:
            with lock:
                if dbf.get_DigestPos():
                    dbf_list.append(dbf)
                    print_colored(f"7-B\n"
                                  f"after {dbf_servant_cycle}s the new DBF created\n"
                                  f"DBF storage size: {len(dbf_list)}", 'blue')
                    dbf = create_bloom_filter()

            start_time = time.time()


def receive_from_brdcast(sock):
    """receive ephids from udp broadcast"""
    data, _ = sock.recvfrom(1024)
    msg_json = data.decode()
    msg = json.loads(msg_json)
    share = msg.get('share')
    ephid_hash = msg.get('ephid_hash')
    sender_node_id = msg.get('node_id')

    return share, ephid_hash, sender_node_id


def receive_shares(node_id=None):
    global dbf, private_key
    """Receive shares over UDP, with a timeout to ensure at least `timeout` seconds of reception."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)
    sock.bind(('', port))

    start_time = time.time()
    received_shares = {}
    while True:
        # 9s
        if time.time() - start_time > receive_time_out:
            # print_colored(f"meet 9s! got {len(received_shares)} received_shares", 'blue')
            start_time = time.time()
            received_shares = {}
        try:
            share, ephid_hash, sender_node_id = receive_from_brdcast(sock)
            if sender_node_id == 'attacker':
                print_colored(f"11-B\n"
                              f"receive attacker share: {share}\n")
            if share and ephid_hash and sender_node_id:

                if sender_node_id != node_id:
                    print_colored(f"3-B\n"
                                  f"Share receiving: {share}\n"
                                  f"ephid_hash: {ephid_hash}"
                                  , 'red')
                    if ephid_hash not in received_shares.keys():
                        received_shares[ephid_hash] = [share]
                    else:
                        if share not in received_shares[ephid_hash]:
                            received_shares[ephid_hash].append(share)
                        print_colored(f"3-C:\n"
                                      f"Received {len(received_shares[ephid_hash])} shares"
                                      , 'red')
                        if len(received_shares[ephid_hash]) >= k:
                            print_colored(f"4-A:\n"
                                          f"Received {k} shares {received_shares[ephid_hash]}\n "
                                          , 'red')
                            ephid, reconstructed_ephid_hash = reconstruct_shares(
                                received_shares[ephid_hash],
                                ephid_hash)
                            if ephid:
                                encid = generate_encid(private_key, ephid)
                                print_colored(f"5-B\n"
                                              f"Shared_secret is Encid: {encid.hex()}"
                                              , 'red')
                                with lock:
                                    dbf.add(encid)
                                    print_colored(
                                        f"6\n"
                                        f"Encid: {encid.hex()} add into DBF\n and deleted the Ephid"
                                        , 'light_yellow')
                                    print_colored(
                                        f"7-A\n"
                                        f"the state of DBF {dbf.get_DigestPos()}"
                                        , 'red')

        except socket.timeout:
            print_colored("Timeout reached or no more shares received.")


#
def send_shares(node_id=None):
    global private_key
    """Generate and broadcast EphID shares every `interval` seconds."""
    cnt = 0
    while True:
        cnt += 1
        private_key, ephid, ephid_hash = generate_ephid()
        shares = split_ephid(ephid)
        print_colored(f"1\n"
                      f"No: {cnt}\n"
                      f"EphID created: {ephid.hex()}\n"
                      f"EphID-hash: {ephid_hash}\n"
                      , 'light_green')

        print_colored(f"2\n"
                      f"EphID-shares: {shares}\n"
                      , 'green')

        # Broadcast shares
        broadcast_shares(shares, ephid_hash, node_id)

        # Wait for the interval before generating a new EphID
        time.sleep(interval)


def send_qbf_to_server():
    global dbf_list, is_virus_infected
    start_time = time.time()
    while True:
        # Combine DBFs into QBF every 9 minutes
        if time.time() - start_time >= helper.dbf_life_cycle and not is_virus_infected and dbf_list:
            qbf = create_bloom_filter()
            qbf.merge(dbf_list)
            print_colored(
                "8\n"
                "meet {}s all the DBFs merged into QBF{}".format(helper.dbf_life_cycle,
                                                                 qbf.get_DigestPos()),
                'blue')

            upload_bf_to_backend(qbf)
            print_colored("10-A\n"
                          "Upload {}:{} to server".format('QBF', qbf.get_DigestPos()), 'blue')

            # Reset the timer and clear the dbf_list
            start_time = time.time()
            with lock:
                dbf_list.clear()


def report_virus():
    global dbf_list, local_encid
    cbf = create_bloom_filter()
    cbf.merge(dbf_list)
    print_colored("9\n"
                  "uploads CBF to server\n{}".format(cbf.get_DigestPos()), 'blue')
    upload_bf_to_backend(cbf, 'cbf')

    with lock:
        dbf_list.clear()


def input_listener():
    global is_virus_infected
    while True:
        user_input = input().strip().upper()
        is_virus_infected = True if user_input == 'Y' else False

        if is_virus_infected and dbf_list:
            report_virus()


def main():
    # Start the periodic EphID generation and broadcasting in a separate thread
    broadcast_thread = threading.Thread(target=send_shares,
                                        args=(node_id,))
    broadcast_thread.start()

    # Start receiving shares in a separate thread
    receive_thread = threading.Thread(target=receive_shares,
                                      args=(node_id,))
    receive_thread.start()

    tcp_send_thread = threading.Thread(target=send_qbf_to_server)
    tcp_send_thread.start()

    virus_check_thread = threading.Thread(target=create_new_dbf)
    virus_check_thread.start()

    input_thread = threading.Thread(target=input_listener, daemon=True)
    input_thread.start()


if __name__ == '__main__':
    main()
